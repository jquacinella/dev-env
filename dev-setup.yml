---
- name: Setup Ubuntu Development Environment
  hosts: localhost
  connection: local
  become: yes
  vars:
    user_name: "{{ ansible_env.SUDO_USER | default(ansible_env.USER) }}"
    user_home: "{{ ansible_env.HOME }}"
    
  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install basic dependencies
      apt:
        name:
          - git
          - curl
          - wget
          - build-essential
          - zsh
          - tmux
          - ccze
          - direnv
        state: present

    # ZSH Setup
    - name: Check if oh-my-zsh is installed
      stat:
        path: "{{ user_home }}/.oh-my-zsh"
      register: ohmyzsh_stat
      become: no

    - name: Install oh-my-zsh
      shell: |
        sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
      args:
        creates: "{{ user_home }}/.oh-my-zsh"
      become: no
      when: not ohmyzsh_stat.stat.exists

    - name: Set zsh as default shell
      user:
        name: "{{ user_name }}"
        shell: /usr/bin/zsh

    # FZF Setup
    - name: Clone fzf repository
      git:
        repo: 'https://github.com/junegunn/fzf.git'
        dest: "{{ user_home }}/.fzf"
        depth: 1
        update: yes
      become: no

    - name: Install fzf
      shell: "{{ user_home }}/.fzf/install --all --no-bash --no-fish"
      args:
        creates: "{{ user_home }}/.fzf/bin/fzf"
      become: no

    # BCAT Setup
    - name: Check if bcat is installed
      stat:
        path: /usr/local/bin/bcat
      register: bcat_stat

    - name: Download and install bcat
      block:
        - name: Create temporary directory for bcat
          tempfile:
            state: directory
          register: bcat_temp

        - name: Download bcat
          get_url:
            url: https://raw.githubusercontent.com/rtomayko/bcat/master/bin/bcat
            dest: "{{ bcat_temp.path }}/bcat"
            mode: '0755'

        - name: Install bcat to /usr/local/bin
          copy:
            src: "{{ bcat_temp.path }}/bcat"
            dest: /usr/local/bin/bcat
            mode: '0755'
            remote_src: yes

        - name: Clean up bcat temporary directory
          file:
            path: "{{ bcat_temp.path }}"
            state: absent
      when: not bcat_stat.stat.exists

    # UP (Ultimate Plumber) Setup
    - name: Check if up is installed
      stat:
        path: /usr/local/bin/up
      register: up_stat

    - name: Download and install up (Ultimate Plumber)
      block:
        - name: Get latest up release info
          uri:
            url: https://api.github.com/repos/akavel/up/releases/latest
            return_content: yes
          register: up_release

        - name: Set up download URL
          set_fact:
            up_download_url: "{{ up_release.json.assets | selectattr('name', 'match', '.*linux_amd64.*') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for up
          tempfile:
            state: directory
          register: up_temp

        - name: Download up tarball
          get_url:
            url: "{{ up_download_url }}"
            dest: "{{ up_temp.path }}/up.tar.gz"

        - name: Extract up binary
          unarchive:
            src: "{{ up_temp.path }}/up.tar.gz"
            dest: "{{ up_temp.path }}"
            remote_src: yes

        - name: Install up to /usr/local/bin
          copy:
            src: "{{ up_temp.path }}/up"
            dest: /usr/local/bin/up
            mode: '0755'
            remote_src: yes

        - name: Clean up up temporary directory
          file:
            path: "{{ up_temp.path }}"
            state: absent
      when: not up_stat.stat.exists

    # Ripgrep Setup
    - name: Check if ripgrep is installed
      stat:
        path: /usr/local/bin/rg
      register: ripgrep_stat

    - name: Download and install ripgrep
      block:
        - name: Get latest ripgrep release info
          uri:
            url: https://api.github.com/repos/BurntSushi/ripgrep/releases/latest
            return_content: yes
          register: ripgrep_release

        - name: Set ripgrep download URL
          set_fact:
            ripgrep_download_url: "{{ ripgrep_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for ripgrep
          tempfile:
            state: directory
          register: ripgrep_temp

        - name: Download ripgrep tarball
          get_url:
            url: "{{ ripgrep_download_url }}"
            dest: "{{ ripgrep_temp.path }}/ripgrep.tar.gz"

        - name: Extract ripgrep tarball
          unarchive:
            src: "{{ ripgrep_temp.path }}/ripgrep.tar.gz"
            dest: "{{ ripgrep_temp.path }}"
            remote_src: yes

        - name: Find ripgrep binary in extracted directory
          find:
            paths: "{{ ripgrep_temp.path }}"
            patterns: "rg"
            recurse: yes
            file_type: file
          register: ripgrep_binary

        - name: Install ripgrep to /usr/local/bin
          copy:
            src: "{{ ripgrep_binary.files[0].path }}"
            dest: /usr/local/bin/rg
            mode: '0755'
            remote_src: yes

        - name: Clean up ripgrep temporary directory
          file:
            path: "{{ ripgrep_temp.path }}"
            state: absent
      when: not ripgrep_stat.stat.exists
    # Espanso Setup
    - name: Install Espanso dependencies
      apt:
        name:
          - libx11-dev
          - libxtst-dev
          - libxkbcommon-dev
          - libdbus-1-dev
          - libwxgtk3.0-gtk3-dev
        state: present

    - name: Check if Espanso is installed
      stat:
        path: /usr/local/bin/espanso
      register: espanso_stat

    - name: Download and install Espanso
      block:
        - name: Get latest Espanso release info
          uri:
            url: https://api.github.com/repos/espanso/espanso/releases/latest
            return_content: yes
          register: espanso_release

        - name: Set Espanso download URL
          set_fact:
            espanso_download_url: "{{ espanso_release.json.assets | selectattr('name', 'match', '.*Espanso-Debian.*\\.deb$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for Espanso
          tempfile:
            state: directory
          register: espanso_temp

        - name: Download Espanso .deb package
          get_url:
            url: "{{ espanso_download_url }}"
            dest: "{{ espanso_temp.path }}/espanso.deb"

        - name: Install Espanso package
          apt:
            deb: "{{ espanso_temp.path }}/espanso.deb"
            state: present

        - name: Clean up Espanso temporary directory
          file:
            path: "{{ espanso_temp.path }}"
            state: absent
      when: not espanso_stat.stat.exists

    - name: Register Espanso systemd service for user
      shell: espanso service register
      become: no
      register: espanso_register
      failed_when: espanso_register.rc != 0 and 'already registered' not in espanso_register.stderr
      changed_when: espanso_register.rc == 0
      when: not espanso_stat.stat.exists

    - name: Start Espanso service
      shell: espanso start
      become: no
      ignore_errors: yes
      when: not espanso_stat.stat.exists

    # Dust Setup
    - name: Check if dust is installed
      stat:
        path: /usr/local/bin/dust
      register: dust_stat

    - name: Download and install dust
      block:
        - name: Get latest dust release info
          uri:
            url: https://api.github.com/repos/bootandy/dust/releases/latest
            return_content: yes
          register: dust_release

        - name: Set dust download URL
          set_fact:
            dust_download_url: "{{ dust_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for dust
          tempfile:
            state: directory
          register: dust_temp

        - name: Download dust tarball
          get_url:
            url: "{{ dust_download_url }}"
            dest: "{{ dust_temp.path }}/dust.tar.gz"

        - name: Extract dust tarball
          unarchive:
            src: "{{ dust_temp.path }}/dust.tar.gz"
            dest: "{{ dust_temp.path }}"
            remote_src: yes

        - name: Find dust binary in extracted directory
          find:
            paths: "{{ dust_temp.path }}"
            patterns: "dust"
            recurse: yes
            file_type: file
          register: dust_binary

        - name: Install dust to /usr/local/bin
          copy:
            src: "{{ dust_binary.files[0].path }}"
            dest: /usr/local/bin/dust
            mode: '0755'
            remote_src: yes

        - name: Clean up dust temporary directory
          file:
            path: "{{ dust_temp.path }}"
            state: absent
      when: not dust_stat.stat.exists

    # xh Setup
    - name: Check if xh is installed
      stat:
        path: /usr/local/bin/xh
      register: xh_stat

    - name: Download and install xh
      block:
        - name: Get latest xh release info
          uri:
            url: https://api.github.com/repos/ducaale/xh/releases/latest
            return_content: yes
          register: xh_release

        - name: Set xh download URL
          set_fact:
            xh_download_url: "{{ xh_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for xh
          tempfile:
            state: directory
          register: xh_temp

        - name: Download xh tarball
          get_url:
            url: "{{ xh_download_url }}"
            dest: "{{ xh_temp.path }}/xh.tar.gz"

        - name: Extract xh tarball
          unarchive:
            src: "{{ xh_temp.path }}/xh.tar.gz"
            dest: "{{ xh_temp.path }}"
            remote_src: yes

        - name: Find xh binary in extracted directory
          find:
            paths: "{{ xh_temp.path }}"
            patterns: "xh"
            recurse: yes
            file_type: file
          register: xh_binary

        - name: Install xh to /usr/local/bin
          copy:
            src: "{{ xh_binary.files[0].path }}"
            dest: /usr/local/bin/xh
            mode: '0755'
            remote_src: yes

        - name: Clean up xh temporary directory
          file:
            path: "{{ xh_temp.path }}"
            state: absent
      when: not xh_stat.stat.exists

    # broot Setup
    - name: Check if broot is installed
      stat:
        path: /usr/local/bin/broot
      register: broot_stat

    - name: Download and install broot
      block:
        - name: Get latest broot release info
          uri:
            url: https://api.github.com/repos/Canop/broot/releases/latest
            return_content: yes
          register: broot_release

        - name: Set broot download URL
          set_fact:
            broot_download_url: "{{ broot_release.json.assets | selectattr('name', 'match', '.*x86_64-linux.zip$') | map(attribute='browser_download_url') | first }}"

        - name: Install unzip if not present
          apt:
            name: unzip
            state: present

        - name: Create temporary directory for broot
          tempfile:
            state: directory
          register: broot_temp

        - name: Download broot zip
          get_url:
            url: "{{ broot_download_url }}"
            dest: "{{ broot_temp.path }}/broot.zip"

        - name: Extract broot zip
          unarchive:
            src: "{{ broot_temp.path }}/broot.zip"
            dest: "{{ broot_temp.path }}"
            remote_src: yes

        - name: Find broot binary in extracted directory
          find:
            paths: "{{ broot_temp.path }}"
            patterns: "broot"
            recurse: yes
            file_type: file
          register: broot_binary

        - name: Install broot to /usr/local/bin
          copy:
            src: "{{ broot_binary.files[0].path }}"
            dest: /usr/local/bin/broot
            mode: '0755'
            remote_src: yes

        - name: Clean up broot temporary directory
          file:
            path: "{{ broot_temp.path }}"
            state: absent
      when: not broot_stat.stat.exists

    # procs Setup
    - name: Check if procs is installed
      stat:
        path: /usr/local/bin/procs
      register: procs_stat

    - name: Download and install procs
      block:
        - name: Get latest procs release info
          uri:
            url: https://api.github.com/repos/dalance/procs/releases/latest
            return_content: yes
          register: procs_release

        - name: Set procs download URL
          set_fact:
            procs_download_url: "{{ procs_release.json.assets | selectattr('name', 'match', '.*x86_64-lnx.zip$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for procs
          tempfile:
            state: directory
          register: procs_temp

        - name: Download procs zip
          get_url:
            url: "{{ procs_download_url }}"
            dest: "{{ procs_temp.path }}/procs.zip"

        - name: Extract procs zip
          unarchive:
            src: "{{ procs_temp.path }}/procs.zip"
            dest: "{{ procs_temp.path }}"
            remote_src: yes

        - name: Find procs binary in extracted directory
          find:
            paths: "{{ procs_temp.path }}"
            patterns: "procs"
            recurse: yes
            file_type: file
          register: procs_binary

        - name: Install procs to /usr/local/bin
          copy:
            src: "{{ procs_binary.files[0].path }}"
            dest: /usr/local/bin/procs
            mode: '0755'
            remote_src: yes

        - name: Clean up procs temporary directory
          file:
            path: "{{ procs_temp.path }}"
            state: absent
      when: not procs_stat.stat.exists

    # bottom Setup
    - name: Check if bottom is installed
      stat:
        path: /usr/local/bin/btm
      register: bottom_stat

    - name: Download and install bottom
      block:
        - name: Get latest bottom release info
          uri:
            url: https://api.github.com/repos/ClementTsang/bottom/releases/latest
            return_content: yes
          register: bottom_release

        - name: Set bottom download URL
          set_fact:
            bottom_download_url: "{{ bottom_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for bottom
          tempfile:
            state: directory
          register: bottom_temp

        - name: Download bottom tarball
          get_url:
            url: "{{ bottom_download_url }}"
            dest: "{{ bottom_temp.path }}/bottom.tar.gz"

        - name: Extract bottom tarball
          unarchive:
            src: "{{ bottom_temp.path }}/bottom.tar.gz"
            dest: "{{ bottom_temp.path }}"
            remote_src: yes

        - name: Find bottom binary in extracted directory
          find:
            paths: "{{ bottom_temp.path }}"
            patterns: "btm"
            recurse: yes
            file_type: file
          register: bottom_binary

        - name: Install bottom to /usr/local/bin
          copy:
            src: "{{ bottom_binary.files[0].path }}"
            dest: /usr/local/bin/btm
            mode: '0755'
            remote_src: yes

        - name: Clean up bottom temporary directory
          file:
            path: "{{ bottom_temp.path }}"
            state: absent
      when: not bottom_stat.stat.exists

    # Zellij Setup
    - name: Check if zellij is installed
      stat:
        path: /usr/local/bin/zellij
      register: zellij_stat

    - name: Download and install zellij
      block:
        - name: Get latest zellij release info
          uri:
            url: https://api.github.com/repos/zellij-org/zellij/releases/latest
            return_content: yes
          register: zellij_release

        - name: Set zellij download URL
          set_fact:
            zellij_download_url: "{{ zellij_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for zellij
          tempfile:
            state: directory
          register: zellij_temp

        - name: Download zellij tarball
          get_url:
            url: "{{ zellij_download_url }}"
            dest: "{{ zellij_temp.path }}/zellij.tar.gz"

        - name: Extract zellij tarball
          unarchive:
            src: "{{ zellij_temp.path }}/zellij.tar.gz"
            dest: "{{ zellij_temp.path }}"
            remote_src: yes

        - name: Find zellij binary in extracted directory
          find:
            paths: "{{ zellij_temp.path }}"
            patterns: "zellij"
            recurse: yes
            file_type: file
          register: zellij_binary

        - name: Install zellij to /usr/local/bin
          copy:
            src: "{{ zellij_binary.files[0].path }}"
            dest: /usr/local/bin/zellij
            mode: '0755'
            remote_src: yes

        - name: Clean up zellij temporary directory
          file:
            path: "{{ zellij_temp.path }}"
            state: absent
      when: not zellij_stat.stat.exists
    
    # gping Setup
    - name: Check if gping is installed
      stat:
        path: /usr/local/bin/gping
      register: gping_stat

    - name: Download and install gping
      block:
        - name: Get latest gping release info
          uri:
            url: https://api.github.com/repos/orf/gping/releases/latest
            return_content: yes
          register: gping_release

        - name: Set gping download URL
          set_fact:
            gping_download_url: "{{ gping_release.json.assets | selectattr('name', 'match', '.*Linux-x86_64.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for gping
          tempfile:
            state: directory
          register: gping_temp

        - name: Download gping tarball
          get_url:
            url: "{{ gping_download_url }}"
            dest: "{{ gping_temp.path }}/gping.tar.gz"

        - name: Extract gping tarball
          unarchive:
            src: "{{ gping_temp.path }}/gping.tar.gz"
            dest: "{{ gping_temp.path }}"
            remote_src: yes

        - name: Find gping binary in extracted directory
          find:
            paths: "{{ gping_temp.path }}"
            patterns: "gping"
            recurse: yes
            file_type: file
          register: gping_binary

        - name: Install gping to /usr/local/bin
          copy:
            src: "{{ gping_binary.files[0].path }}"
            dest: /usr/local/bin/gping
            mode: '0755'
            remote_src: yes

        - name: Clean up gping temporary directory
          file:
            path: "{{ gping_temp.path }}"
            state: absent
      when: not gping_stat.stat.exists
    
    # bandwhich Setup
    - name: Check if bandwhich is installed
      stat:
        path: /usr/local/bin/bandwhich
      register: bandwhich_stat

    - name: Download and install bandwhich
      block:
        - name: Get latest bandwhich release info
          uri:
            url: https://api.github.com/repos/imsnif/bandwhich/releases/latest
            return_content: yes
          register: bandwhich_release

        - name: Set bandwhich download URL
          set_fact:
            bandwhich_download_url: "{{ bandwhich_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for bandwhich
          tempfile:
            state: directory
          register: bandwhich_temp

        - name: Download bandwhich tarball
          get_url:
            url: "{{ bandwhich_download_url }}"
            dest: "{{ bandwhich_temp.path }}/bandwhich.tar.gz"

        - name: Extract bandwhich tarball
          unarchive:
            src: "{{ bandwhich_temp.path }}/bandwhich.tar.gz"
            dest: "{{ bandwhich_temp.path }}"
            remote_src: yes

        - name: Find bandwhich binary in extracted directory
          find:
            paths: "{{ bandwhich_temp.path }}"
            patterns: "bandwhich"
            recurse: yes
            file_type: file
          register: bandwhich_binary

        - name: Install bandwhich to /usr/local/bin
          copy:
            src: "{{ bandwhich_binary.files[0].path }}"
            dest: /usr/local/bin/bandwhich
            mode: '0755'
            remote_src: yes

        - name: Clean up bandwhich temporary directory
          file:
            path: "{{ bandwhich_temp.path }}"
            state: absent
      when: not bandwhich_stat.stat.exists

    # bat (batcat) Setup
    - name: Check if bat is installed
      stat:
        path: /usr/local/bin/bat
      register: bat_stat

    - name: Download and install bat
      block:
        - name: Get latest bat release info
          uri:
            url: https://api.github.com/repos/sharkdp/bat/releases/latest
            return_content: yes
          register: bat_release

        - name: Set bat download URL
          set_fact:
            bat_download_url: "{{ bat_release.json.assets | selectattr('name', 'match', '.*x86_64-unknown-linux-musl.tar.gz$') | map(attribute='browser_download_url') | first }}"

        - name: Create temporary directory for bat
          tempfile:
            state: directory
          register: bat_temp

        - name: Download bat tarball
          get_url:
            url: "{{ bat_download_url }}"
            dest: "{{ bat_temp.path }}/bat.tar.gz"

        - name: Extract bat tarball
          unarchive:
            src: "{{ bat_temp.path }}/bat.tar.gz"
            dest: "{{ bat_temp.path }}"
            remote_src: yes

        - name: Find bat binary in extracted directory
          find:
            paths: "{{ bat_temp.path }}"
            patterns: "bat"
            recurse: yes
            file_type: file
          register: bat_binary

        - name: Install bat to /usr/local/bin
          copy:
            src: "{{ bat_binary.files[0].path }}"
            dest: /usr/local/bin/bat
            mode: '0755'
            remote_src: yes

        - name: Clean up bat temporary directory
          file:
            path: "{{ bat_temp.path }}"
            state: absent
      when: not bat_stat.stat.exists

    # Configuration Files
    - name: Create config directory
      file:
        path: "{{ user_home }}/.config"
        state: directory
        owner: "{{ user_name }}"
        mode: '0755'
      become: no

    - name: Copy custom zshrc
      template:
        src: ./configs/zshrc.j2
        dest: "{{ user_home }}/.zshrc"
        owner: "{{ user_name }}"
        mode: '0644'
      become: no
      when: false  # Enable this when you create the config file

    - name: Copy custom tmux.conf
      template:
        src: ./configs/tmux.conf.j2
        dest: "{{ user_home }}/.tmux.conf"
        owner: "{{ user_name }}"
        mode: '0644'
      become: no
      when: false  # Enable this when you create the config file

    - name: Setup direnv hook for zsh
      lineinfile:
        path: "{{ user_home }}/.zshrc"
        line: 'eval "$(direnv hook zsh)"'
        create: yes
        owner: "{{ user_name }}"
      become: no

  handlers:
    - name: reload shell
      debug:
        msg: "Shell configuration updated. Please restart your terminal or run 'source ~/.zshrc'"
